#!/bin/sh
# Script which performs updating services
############################################################################

# Source our functions
. /usr/local/share/pcbsd/scripts/functions.sh

# Set the program location
PROGDIR="/usr/local/share/pcbsd/pc-updatemanager" ; export PROGDIR

# Start by sourcing /etc/profile
# This grabs any HTTP_ / FTP_ PROXY variables
. /etc/profile

PCBSD_ETCCONF="/usr/local/etc/pcbsd.conf"
export PCBSD_ETCCONF

# Set the pub openssl key
SKEY="${PROGDIR}/conf/security.key" ; export SKEY

# Directory to store downloaded updates
DOWNLOADDIR="/usr/local/tmp"

# Get the system version we are checking for updates to
SYSVER="`uname -r | cut -d '-' -f 1-2`" ; export SYSVER

# Get the system type
SYSTYPE="`/usr/local/bin/pbreg get /PC-BSD/SysType`" ; export SYSTYPE

# Set the config location
UPDATECONF="${PROGDIR}/conf/sysupdate.conf"

# Set the system arch type
ARCH=`uname -m`

# Patchset Data
PATCHSERVER="`cat ${UPDATECONF} | grep '^UPDATESERVER:' | cut -d ' ' -f 2`"
PATCHSET="`cat ${UPDATECONF} | grep '^PATCHSET:' | cut -d ' ' -f 2`"
PATCHFILE="${PATCHSET}.upd"
PATCHURL="${PATCHSERVER}/${PATCHFILE}"
PATCHTMPDIR=`mktemp -d /tmp/.sysupdateXXXXXX`
PATCHTMPFILE="${PATCHTMPDIR}/sysupdate-${SYSVER}.upd"

MUSTAGEDIR="${DOWNLOADDIR}/update-stagedir"

# Enable ftp passive mode for file transfers
FTP_PASSIVE_MODE="YES" ; export FTP_PASSIVE_MODE

if [ ! -d "${DOWNLOADDIR}" ]; then mkdir -p ${DOWNLOADDIR}; fi


# Trigger File for Tray Application
TRIGGERFILE="/tmp/.sysupdatetraytrigger"

DBDIR="/var/db/pc-updatemanager"
INSDIR="${DBDIR}/installed"
IGNDIR="${DBDIR}/ignored"

# PKG_CMD to use
PKG_CMD="/usr/sbin/pkg"

# Make sure we don't keep these from system environment
unset INJAIL PKG_FLAG

ISOTMP="/usr/local/tmp/pcbsd-update.iso"

######################################################################
# Done with config values
######################################################################

# Get the PACKAGE_SET to use for this pkgng repo
PACKAGE_SET="PRODUCTION"
_pkgChk="`sed -n 's/PACKAGE_SET: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
if [ -n "${_pkgChk}" ] ; then PACKAGE_SET="$_pkgChk" ; fi

# Check the PACKAGE_SET variable
case $PACKAGE_SET in
   PRODUCTION|EDGE) ;;
  CUSTOM) # Using a custom package set?
          # Lets check that we have a URL provided
	  _urlChk="`sed -n 's/^PACKAGE_URL: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
	     echo "Warning: PACKAGE_SET is CUSTOM, but no PACKAGE_URL set!"
	     echo "Reverting back to PRODUCTION repo..."
	     sleep 3
             CUSTOM_URL=""
	     PACKAGE_SET="PRODUCTION"
	  else
	     CUSTOM_URL="$_urlChk"
          fi
	  _urlChk="`sed -n 's/^CURSYS_PACKAGE_URL: //p' ${PCBSD_ETCCONF} 2>/dev/null | awk '{print $1}'`"
	  if [ -z "${_urlChk}" ] ; then
             CUSTOM_CURSYS_URL=""
	  else
	     CUSTOM_CURSYS_URL="$_urlChk"
          fi
          ;;
       *) echo "Warning: Invalid PACKAGE_SET!" 
          PACKAGE_SET="PRODUCTION" ;; 
esac

show_usage() {
        echo "pc-updatemanager: Usage
----
  branches 		- List available system branches
  chbranch <tag> 	- Change to new system branch
  check 		- Check for system updates
  install <tag>,<tag2> 	- Install system updates
  pkgcheck 		- Check for updates to packages
  pkgupdate 		- Install packages updates
  syncconf		- Update PC-BSD pkgng configuration
  confcheck		- Check PC-BSD pkgng configuration
  cron                  - Perform delayed check for system and pkgng updates.
  -j <jail>		- Operate on the jail specified
"	

	exit 1
}

setup_pkgng_conf() {

  # See if we need to adjust pcbsd.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/pcbsd.conf.dist" ];then
     echo "WARNING: Missing /usr/local/etc/pkg/repos/pcbsd.conf.dist"
     status="1"
     return 1
  fi

  # Remove old pkg conf
  if [ -e "/usr/local/etc/pkg/repos/pcbsd.conf" ] ; then
    rm /usr/local/etc/pkg/repos/pcbsd.conf
  fi

  ARCH=`uname -m`
  FBSDVER=`uname -r | cut -d '-' -f 1-2`
  MAJORVER="`uname -r | cut -d '-' -f 1 |  cut -d '.' -f 1`.0-RELEASE"

  # Make sure we are on a -RELEASE, otherwise use the proper uname
  echo $FBSDVER | grep -q -e 'RELEASE' -e 'STABLE'
  if [ $? -ne 0 ] ; then MAJORVER="$FBSDVER"; fi

  # If using the EDGE package set, set the right path
  case $PACKAGE_SET in
       EDGE) FBSDVER="$FBSDVER/edge"
	     MAJORVER="$MAJORVER/edge"
	     ;;
          *) ;;
  esac

  # Now create standard pcbsd.conf file
  if [ "$PACKAGE_SET" = "CUSTOM" -a -n "$CUSTOM_URL" ] ; then
     cat << EOF >/usr/local/etc/pkg/repos/pcbsd.conf
pcbsd-major: {
               url: "$CUSTOM_URL",
               signature_type: "fingerprints",
               fingerprints: "/usr/local/etc/pkg/fingerprints/pcbsd",
               enabled: true
              }
EOF
  else
     # Using PC-BSD CDN
     cat /usr/local/etc/pkg/repos/pcbsd.conf.dist \
	| sed "s|pcbsd: |pcbsd-major: |g" \
	| sed "s|VERSION|$MAJORVER|g" \
	| sed "s|ARCH|$ARCH|g" > /usr/local/etc/pkg/repos/pcbsd.conf
  fi

  if [ -e "/usr/local/etc/pkg/repos/01pcbsd.conf" ] ; then
     rm /usr/local/etc/pkg/repos/local-pcbsd.conf >/dev/null 2>/dev/null #eventually remove
     rm /usr/local/etc/pkg/repos/01pcbsd.conf
  fi
}

get_update_file() {

  # Now fetch the update file
  get_file "${PATCHURL}" "${PATCHTMPFILE}" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0 
     else
       exit_err "Could not contact update server!"
     fi
  fi

  # Now fetch the update file signature
  get_file "${PATCHURL}.sha1" "${PATCHTMPFILE}.sha1" 1 >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     is_net_up
     if [ $? -eq 0 ] ; then 
       echo "No updates available for $SYSVER!" ; exit 0 
     else
       exit_err "Could not contact update server!"
     fi
  fi

  # Lets verify the signature of the file
  openssl dgst -sha1 -verify ${SKEY} \
	-signature ${PATCHTMPFILE}.sha1 \
        ${PATCHTMPFILE} >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE} 2>/dev/null
     rm ${PATCHTMPFILE}.sha1 2>/dev/null
     exit_err "Update file failed verification..."
  fi

  # Done with the signature we can discard
  rm ${PATCHTMPFILE}.sha1

}

do_branch() {
  up="$1"

  # Setup our variable to catch if we have a bad branch
  BRANCHFOUND="0" 

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	for i in `echo $line | cut -d ':' -f 2 | sed 's|,| |g'`
	do
  	  if [ "$i" != "$up" ] ; then continue ;fi
  	  if [ "`uname -r | cut -d '-' -f 1-2`" = "$up" ] ; then 
	     echo "You are already on this branch!"
             BRANCHFOUND="1"
	     continue;
	  fi
          update_world_and_pkgs "$up"
          BRANCHFOUND="1"
	  break
	done
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then 
     # No available updates
     echo "Unknown branch ${1}"
  fi

  rm ${PATCHTMPFILE}

};

list_branches() {
  # Setup our variable, we have no branches so far
  BRANCHFOUND="0" 

  while read line
  do
     echo $line | grep -q "^BRANCHES:"
     if [ $? -eq 0 ] ; then
	echo "Available branches:"
	echo "* = Current Branch"
        echo "----------------------------------"
	echo $line | cut -d ':' -f 2 | sed 's|,|\
|g' | while read branch
	do
		if [ "`uname -r | cut -d '-' -f 1-2`" = "$branch" ] ; then
			echo "$branch *"
		else
			echo "$branch"
		fi
	done
	echo ""
	echo "To change branches run: ${0} chbranch <branch>"
        BRANCHFOUND="1"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${BRANCHFOUND}" = "0" ]; then 
     # No available updates
     echo "No branches currently available!"
  fi

  rm ${PATCHTMPFILE}

};

do_fbsdcheck() {
  # Setup our variable, we have no patches so far
  PATCHFOUND="0" 
  echo "Checking for FreeBSD updates..."
  pc-fbsdupdatecheck | grep -q "will be updated"
  if [ $? -eq 0 ] ; then
     PATCHFOUND="1"
  fi

  if [ "${PATCHFOUND}" = "1" ]; then
    echo "The following updates are available:"
    echo "------------------------------------"
    echo "NAME: FreeBSD system update"
    echo "TYPE: System Update"
    echo " "
    echo "Install: \"freebsd-update fetch && freebsd-update install\""
    echo " "

    if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
      pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
    fi
  fi
}

do_check() {

  while read line
  do
     echo $line | grep -q "^MAJOR:"
     if [ $? -eq 0 ] ; then
        parse_mu_update_line "$line"
        continue
     fi
     echo $line | grep -q "^SA:"
     if [ $? -eq 0 ] ; then
        parse_sa_update_line "$line"
        continue
     fi
  done < ${PATCHTMPFILE}

  # If no patches
  if [ "${PATCHFOUND}" = "0" ]; then 
     # No available updates
     echo "Your system is up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
       pc-systemflag SYSUPDATE SUCCESS #set the system flag that system is up to date
     fi
  else
    if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
      pc-systemflag SYSUPDATE UPDATE #set the system flag that system updates are available
    fi
  fi

  rm ${PATCHTMPFILE}

};

parse_mu_update_line()
{
   local line="$1"

   # Check if this is a major update we can install
   local sysUpOVer=`echo $line | cut -d ':' -f 2`
   local sysUpNVer=`echo $line | cut -d ':' -f 3`

   # Is this an update for our version?
   if [ "$SYSVER" != "$sysUpOVer" ] ; then return; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   echo "NAME: System Update to ${sysUpNVer}" 
   echo "TYPE: SYSUPDATE" 
   echo "TAG: fbsd-${sysUpNVer}"
   echo "VERSION: ${sysUpNVer}" 
   echo ""
   echo "To install: \"pc-updatemanager install fbsd-${sysUpNVer}\""
   echo ""
   echo ""

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
}

parse_sa_update_line()
{
   local line="$1"

   # Check if this is an update we can install
   local saVer=`echo $line | cut -d ':' -f 2`
   local saArch=`echo $line | cut -d ':' -f 3`
   local saType=`echo $line | cut -d ':' -f 4`
   local saIdent="`echo $line | cut -d ':' -f 5`"

   # For this version?
   if [ "$SYSVER" != "$saVer" ] ; then return ; fi

   # For this system arch?
   if [ "$ARCH" != "$saArch" -a "$saArch" != "noarch" ] ; then return ; fi

   # For this system type?
   if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then return ; fi

   # Already installed?
   if [ -e "${INSDIR}/${SYSVER}/$saIdent" ] ; then return ; fi

   if [ $PATCHFOUND -eq 0 ] ; then
      echo ""
      echo "The following updates are available:"
      echo "------------------------------------"
   fi
   local saDesc="`echo $line | cut -d ':' -f 6`"
   local saSize=`echo $line | cut -d ':' -f 8`
   local saDetail="http://wiki.pcbsd.org`echo $line | cut -d ':' -f 10`"
   local saDate="`echo $line | cut -d ':' -f 11`"

   echo "NAME: ${saDesc}" 
   echo "TYPE: PATCH" 
   echo "TAG: ${saIdent}"
   echo "DETAILS: ${saDetail}"
   echo "DATE: ${saDate}"
   echo "SIZE: ${saSize}Mb" 
   echo " "
   echo "To install: \"pc-updatemanager install ${saIdent}\""
   echo " "

   PATCHFOUND="`expr ${PATCHFOUND} + 1`" 
}

start_pcbsd_patch() {
  local up="$1"
  local saIdent=""
  local saVer=""
  local saArch=""
  local saPlat=""
  local saUrl=""
  local saDesc=""
  local saCsum=""
  local patchLine=""
  if [ -e "${INSDIR}/${SYSVER}/${up}" ]; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up already installed!"
  fi

  while read line
  do
    echo $line | grep -q "^SA:"
    if [ $? -ne 0 ] ; then continue; fi
    saIdent="`echo $line | cut -d ':' -f 5`"
    # Look for the right stand-alone update
    if [ "$saIdent" != "$up" ] ; then continue ; fi
    saVer=`echo $line | cut -d ':' -f 2`
    saArch=`echo $line | cut -d ':' -f 3`
    saType=`echo $line | cut -d ':' -f 4`
    # Does this update apply to this system arch?
    if [ "$saArch" != "$ARCH" -a "$saArch" != "noarch" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system arch type!"
    fi
    # For this version?
    if [ "$saVer" != "$SYSVER" ] ; then 
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system version!"
    fi

    # For this system type?
    if [ "$SYSTYPE" != "$saType" -a "$saType" != "both" ] ; then
       rm ${PATCHTMPFILE}
       exit_err "Patch $up is not for this system type!"
    fi

    # Got here? We have a patch ready to go
    patchLine="$line"
    break
  done < ${PATCHTMPFILE}

  # Did we find the patch?
  if [ -z "$patchLine" ] ; then 
     rm ${PATCHTMPFILE}
     exit_err "Patch $up not found!"
  fi

  # Get the patch details
  saVer=`echo $patchLine | cut -d ':' -f 2`
  saArch=`echo $patchLine | cut -d ':' -f 3`
  saPlat=`echo $patchLine | cut -d ':' -f 4`
  saIdent="`echo $patchLine | cut -d ':' -f 5`"
  saDesc="`echo $patchLine | cut -d ':' -f 6`"
  saUrl="`echo $patchLine | cut -d ':' -f 7`"
  saCsum="`echo $patchLine | cut -d ':' -f 9`"
  local FILENAME="`basename $saUrl`"

  # Start downloading the patch
  touch ${TRIGGERFILE}
  echo "DOWNLOADING: ${saIdent}"
  echo "DOWNLOADING: ${saIdent}" >${TRIGGERFILE}

  # Get the file
  get_file_from_mirrors "/${saUrl}" "${DOWNLOADDIR}/${FILENAME}" "update"
  if [ $? -ne 0 ] ; then
     rm ${PATCHTMPFILE}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  fi

  # Check the sha256 checksum
  if [ "$saCsum" != "`sha256 -q ${DOWNLOADDIR}/${FILENAME} 2>/dev/null`" ]
  then
     # Download MD5 doesn't match! Delete the file
     rm ${PATCHTMPFILE}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "FAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "Failed to download: ${saIdent}"
  else 
     echo "DOWNLOADFINISHED: ${saIdent}"
     echo "DOWNLOADFINISHED: ${saIdent}" >${TRIGGERFILE}
  fi

  echo "INSTALLING: ${saIdent}" >${TRIGGERFILE}
  sleep 1

  # Lets auto-create a new boot-environment before updating
  create_auto_beadm

  PATCHTMPDIR="`mktemp -d ${DOWNLOADDIR}/patchInstallXXXXX`"
  rc_halt "tar xvJf ${DOWNLOADDIR}/${FILENAME} -C ${PATCHTMPDIR}" 2>/dev/null
  PATCHDIR="$PATCHTMPDIR" ; export PATCHDIR
  cd ${PATCHTMPDIR}
  sh update.sh
  if [ $? -eq 0 ]; then
     touch "${INSDIR}/${SYSVER}/${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}"
     echo "INSTALLFINISHED: ${saIdent}" >${TRIGGERFILE}
  else
     rm ${PATCHTMPFILE}
     rm -rf ${PATCHTMPDIR}
     rm ${DOWNLOADDIR}/${FILENAME}
     echo "INSTALLFAILED: ${saIdent}" >${TRIGGERFILE}
     exit_err "INSTALLFAILED: ${saIdent}"
  fi

  rc_halt "rm -rf ${PATCHTMPDIR}"
  rc_halt "rm ${DOWNLOADDIR}/${FILENAME}"
}

do_install() {
        # Make sure we are root and have specified updates to install
	if [ `id -u` != "0" ] ; then exit_err "Must be run as root!" ; fi
	if [ -z "$1" ] ; then exit_err "No updates specified to install!"; fi

	if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
	  pc-systemflag SYSUPDATE UPDATING #set the flag that system is updating
	fi
	# Begin to update the selected items
	for up in `echo $1 | sed 's|,| |g'`
	do
	  # If this is a major update, start it up!
  	  echo $up | grep -q "^fbsd-" 
	  if [ $? -eq 0 ] ; then 
            update_world_and_pkgs "`echo $up | sed 's|fbsd-||g'`"
	    exit 0
	  elif [ "$up" == "pkg-updates" ] ; then
	    # Check if this is a pkg-update request or regular patch
            start_pkg_updates
            continue
          else
	    # Doing regular pcbsd patch
	    start_pcbsd_patch "${up}"
            continue
          fi

	done 
	if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
	  pc-systemflag SYSUPDATE SUCCESS #set the flag that system updates finished
	fi
        # All Finished!
        rm ${PATCHTMPFILE}
        exit 0
}

is_net_up() {
	ping -c 1 www.pcbsd.org >/dev/null 2>/dev/null
	ret=$?
	if [ $ret -ne 0 ]; then
	  if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
	    pc-systemflag NETRESTART ERROR #set the system flag that no internet available
	  fi
	fi
	return $ret
}

sync_pkgconf() {

  # Update systems pkgng configuration
  setup_pkgng_conf

  if [ -n "$INJAIL" ] ; then
    # Need to update pkgng config in the jail to match systems
    jDir="`jls | grep " $INJAIL " | awk '{print $4}'`"
    if [ ! -d "$jDir/usr/local/etc/pkg/repos" ] ; then
       mkdir -p ${jDir}/usr/local/etc/pkg/repos
    fi
    cp /usr/local/etc/pkg/repos/pcbsd.conf ${jDir}/usr/local/etc/pkg/repos/
  fi
}

check_pkgconf() {

  if [ -n "$INJAIL" ] ; then
    # Update systems pkgng configuration
    setup_pkgng_conf

    # Need to update pkgng config in the jail to match systems
    jDir="`jls | grep " $INJAIL " | awk '{print $4}'`"
    diff /usr/local/etc/pkg/repos/pcbsd.conf ${jDir}/usr/local/etc/pkg/repos/pcbsd.conf >/dev/null 2>/dev/null
    if [ $? -eq 0 ] ; then
       echo "Config OK!"
       exit 0
    else
       exit_err "Config differs from systems"
    fi
  fi

  # Update systems pkgng configuration
  setup_pkgng_conf
  exit $?
}

checkup_pkgs() {

  # If we are checking a jail, check that internet access is up
  if [ -n "$INJAIL" ] ; then
    test_jail_netaccess
  fi

  # Update the repo DB
  rc_halt "${PKG_CMD} update"

  ${PKG_CMD} ${PKG_FLAG} upgrade -n >/tmp/.pkgData.$$
  if [ $? -ne 0 ] ; then
     echo "Error checking for package updates..."
     if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
       pc-systemflag PKGUPDATE ERROR #set the system flag pkg check errored
     fi
     exit 1
  fi

  # Check fr updates now
  grep -q "Your packages are up to date" /tmp/.pkgData.$$
  if [ $? -eq 0 ] ; then
     echo "All packages are up to date!"
     if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
       pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
     fi
     rm /tmp/.pkgData.$$
     return 0
  fi

  # Display the pkg update data
  cat /tmp/.pkgData.$$
  rm /tmp/.pkgData.$$
  echo ""
  echo "To start the upgrade run \"${0} ${PKG_FLAG} pkgupdate\""
  if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
    pc-systemflag PKGUPDATE UPDATE #set the system flag that updates available
  fi
  return 0
}

do_jail_pkg_update()
{
  # User requested update of packages inside a jail, we can let pkgng handle that
  unset EVENT_PIPE

  # Run pkgng with the -j flag, set in PKG_FLAG earlier
  ${PKG_CMD} ${PKG_FLAG} upgrade -y
  return $?
}

update_pkgs_only()
{
  if [ -n "$INJAIL" ] ; then
     do_jail_pkg_update
     exit $?
  fi

  if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi
  unset EVENT_PIPE

  # Set some locations
  STAGEBE="pcupdatestage"
  STAGEMNT="/.updateStage"
  OLDPKGLIST="/tmp/.pkgUpdateList.$$"
  NEWPKGLIST="/tmp/.newPkgUpdateList.$$"
  PKGUPGRADELOG="/tmp/.pkgUpdateLog.$$"
  PKGDLCACHE="/usr/local/tmp/updatePkgs"

  mk_pkg_conf
  build_pkg_list
  dl_pkgs
  mk_stage_be
  mount_stage_be
  prep_pkgs_chroot
  install_pkgs_chroot
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  echo "Your update is finished! Please reboot to load into the new boot-environment"
  exit 0
}

update_world_and_pkgs()
{
  # Set the new version of FreeBSD we are installing
  NEWFREEBSDVERSION="$1"

  if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
    pc-systemflag PKGUPDATE UPDATING #set the system flag that packages are updating
  fi
  unset EVENT_PIPE

  # Set some locations
  STAGEBE="pcupdatestage"
  STAGEMNT="/.updateStage"
  OLDPKGLIST="/tmp/.pkgUpdateList.$$"
  NEWPKGLIST="/tmp/.newPkgUpdateList.$$"
  PKGUPGRADELOG="/tmp/.pkgUpdateLog.$$"
  PKGDLCACHE="/usr/local/tmp/updatePkgs"

  mk_pkg_conf
  build_pkg_list
  dl_pkgs
  mk_stage_be
  mount_stage_be
  prep_pkgs_chroot
  prep_rc_script
  umount_stage_be
  mk_stage_be_default

  if [ -e "/usr/local/bin/pc-systemflag" -a -z "$INJAIL" ]; then
    pc-systemflag PKGUPDATE SUCCESS #set the system flag that packages are up to date
  fi

  echo "Update stage one is finished! Please reboot to start stage 2."

  exit 0
}

mk_pkg_conf()
{
   PKG_FLAG=""

   if [ ! -d "$PKGDLCACHE" ] ; then
     mkdir -p $PKGDLCACHE
   fi

   # If doing a major update also, add the new repos config
   if [ -n "$NEWFREEBSDVERSION" ] ; then
      setup_pkgng_newrepo_conf
   fi
}

setup_pkgng_newrepo_conf() {

  # Lets create a new repo file to match the version of BSD we are upgrading to

  # See if we need to adjust pcbsd.conf repo file
  if [ ! -e "/usr/local/etc/pkg/repos/pcbsd.conf.dist" ];then
     echo "ERROR: Missing /usr/local/etc/pkg/repos/pcbsd.conf.dist"
     exit 1
  fi

  ARCH=`uname -m`
  FBSDVER="$NEWFREEBSDVERSION"
  MAJORVER="`echo $FBSDVER | cut -d '-' -f 1 |  cut -d '.' -f 1`.0-RELEASE"

  # Make sure we are on a -RELEASE or -STABLE, otherwise use the proper uname
  echo $FBSDVER | grep -q -e 'RELEASE' -e 'STABLE'
  if [ $? -ne 0 ] ; then MAJORVER="$FBSDVER"; fi

  # If using the EDGE package set, set the right path
  case $PACKAGE_SET in
       EDGE) FBSDVER="$FBSDVER/edge"
	     MAJORVER="$MAJORVER/edge"
	     ;;
          *) ;;
  esac

  rm -rf /tmp/.updateRepo >/dev/null 2>/dev/null
  mkdir /tmp/.updateRepo

  # Using PC-BSD CDN
  cat /usr/local/etc/pkg/repos/pcbsd.conf.dist \
    | sed "s|pcbsd: |pcbsd-major: |g" \
    | sed "s|VERSION|$MAJORVER|g" \
    | sed "s|ARCH|$ARCH|g" > /tmp/.updateRepo/pkgUpdateRepo.conf

  # Set the new PKG_FLAG to use this repo config
  PKG_FLAG="-R /tmp/.updateRepo"
}

build_pkg_list()
{
  # Figure out which base to install
  pkg info -e pcbsd-base
  if [  $? -eq 0 ] ; then
     SYSBASE="misc/pcbsd-base"
  else
     SYSBASE="misc/trueos-base"
  fi
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"

  # Build top-level list of pkgs installed
  ${PKG_CMD} query -e '%#r=0' '%o %n-%v' | sort | grep -v 'ports-mgmt/pkg ' | grep -v 'misc/pcbsd-base ' | grep -v 'misc/trueos-base ' > $OLDPKGLIST

  echo "Original top-level packages:" > $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
  cat $OLDPKGLIST >> $PKGUPGRADELOG
  echo "-----------------------------------------------" >> $PKGUPGRADELOG
}

dl_pkgs()
{
  # Update the DB first
  echo "Updating the package repo database..."
  ${PKG_CMD} ${PKG_FLAG} update -f >/dev/null 2>/dev/null

  # Clean pkgs
  echo "Cleaning old pkg upgrade cache..."
  ${PKG_CMD} ${PKG_CFLAG} ${PKG_FLAG} clean -y >/dev/null 2>/dev/null

  if [ -e "$NEWPKGLIST" ] ; then rm $NEWPKGLIST; fi

  # Save the PKGNG filename
  PKGFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' ports-mgmt/pkg 2>/dev/null | head -n 1`.txz"

  # First off, fetch the pkgng pkg
  echo "Fetching packages for ports-mgmt/pkg - $PKGFILENAME"
  ${PKG_CMD} ${PKG_FLAG} fetch -U -d -y -o ${PKGDLCACHE} ports-mgmt/pkg >/tmp/.pkgOut.$$ 2>/tmp/.pkgOut.$$
  if [ $? -ne 0 ] ; then
     cat /tmp/.pkgOut.$$
     exit_err "Failed fetching: ports-mgmt/pkg - $PKGFILENAME"
  fi

  REALPKGDLCACHE="${PKGDLCACHE}"
  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${PKGDLCACHE}/${PKGFILENAME}" ] ; then
     # Also check All/ since pkg docs are rather unclear about if that will be used or not
     if [ -e "${PKGDLCACHE}/All/${PKGFILENAME}" ] ; then
        REALPKGDLCACHE="${PKGDLCACHE}/All"
     else
        exit_err "Failed downloading ports-mgmt/pkg with: $PKG_CMD $PKG_FLAG fetch -d -y ports-mgmt/pkg"
     fi
  fi



  # Fetch the SYSBASE packages, halt if this fails
  SYSBASEFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $SYSBASE 2>/dev/null | head -n 1`.txz"
  echo "Fetching packages for ${SYSBASE} - $SYSBASEFILENAME"
  ${PKG_CMD} ${PKG_FLAG} fetch -U -d -y -o ${PKGDLCACHE} ${SYSBASE} >/tmp/.pkgOut.$$ 2>/tmp/.pkgOut.$$
  if [ $? -ne 0 ] ; then
     cat /tmp/.pkgOut.$$
     exit_err "Failed fetching: $SYSBASE - $SYSBASEFILENAME"
  fi

  # PKGNG lies, we need to verify if the package was really downloaded
  if [ ! -e "${REALPKGDLCACHE}/${SYSBASEFILENAME}" ] ; then
     exit_err "Failed downloading $SYSBASE with: $PKG_CMD $PKG_FLAG fetch -d -y $SYSBASE"
  fi



  # Now start fetching all the update packages
  while read pkgLine
  do
    pkgOrigin="`echo $pkgLine | cut -d ' ' -f 1`"
    pkgName="`echo $pkgLine | cut -d ' ' -f 2`"

    # Check if this pkg exists in the new repo
    unset FETCHFILENAME
    FETCHFILENAME="`${PKG_CMD} ${PKG_FLAG} rquery -U '%n-%v' $pkgOrigin 2>/dev/null | head -n 1`"
    if [ -z "$FETCHFILENAME" ] ; then
       echo "*****" >> $PKGUPGRADELOG
       echo "No such package in new repo: $pkgOrigin"
       echo "No such package in new repo: $pkgOrigin" >> $PKGUPGRADELOG
       echo "*****" >> $PKGUPGRADELOG
       continue
    fi
    FETCHFILENAME="${FETCHFILENAME}.txz"

    # Fetch the pkg now
    echo "Fetching packages for ${pkgOrigin} - $FETCHFILENAME"
    echo "Fetching packages for ${pkgOrigin} - $FETCHFILENAME" >> ${PKGUPGRADELOG}
    ${PKG_CMD} ${PKG_FLAG} fetch -U -d -y -o ${PKGDLCACHE} $pkgOrigin >/tmp/.pkgOut.$$ 2>/tmp/.pkgOut.$$
    if [ $? -ne 0 ] ; then
       echo "*****" >> $PKGUPGRADELOG
       echo "Failed fetching: $pkgOrigin"
       echo "Failed fetching: $pkgOrigin" >> $PKGUPGRADELOG
       cat /tmp/.pkgOut.$$
       cat /tmp/.pkgOut.$$ >> $PKGUPGRADELOG
       echo "*****" >> $PKGUPGRADELOG
    fi

    # PKGNG lies, we need to verify if the package was really downloaded
    if [ ! -e "${REALPKGDLCACHE}/${FETCHFILENAME}" ] ; then
       echo "*****" >> $PKGUPGRADELOG
       echo "Failed fetching: $pkgOrigin - $FETCHFILENAME"
       echo "Failed fetching: $pkgOrigin - $FETCHFILENAME" >> $PKGUPGRADELOG
       cat /tmp/.pkgOut.$$ >> $PKGUPGRADELOG
       echo "*****" >> $PKGUPGRADELOG
       echo "Failed downloading $pkgOrigin with: $PKG_CMD $PKG_FLAG fetch -d -y $pkgOrigin"
    fi
    echo "$pkgOrigin $FETCHFILENAME" >> $NEWPKGLIST
  done < $OLDPKGLIST

  echo "-----------------------------------------------" >> ${PKGUPGRADELOG}
}

mk_stage_be()
{
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Check for an existing BE for upgrades
  beadm list -H | awk '{print $1}' | grep -q "$STAGEBE"
  if [ $? -eq 0 ] ; then
     beadm destroy -F $STAGEBE
  fi

  # Create the new stage boot environment
  rc_halt "beadm create $STAGEBE"
}

mount_stage_be()
{
  # Get the stage mount-point ready
  if [ ! -d "$STAGEMNT" ] ; then mkdir -p $STAGEMNT; fi
  umount -f $STAGEMNT/dev 2>/dev/null >/dev/null
  umount -f $STAGEMNT 2>/dev/null >/dev/null

  # Mount the BE
  rc_halt "beadm mount $STAGEBE $STAGEMNT"
  rc_halt "cp $NEWPKGLIST ${STAGEMNT}/install-pkg-list"
  rc_halt "mount -t devfs devfs ${STAGEMNT}/dev"
  
}

prep_pkgs_chroot()
{
  # Now start our chroot commands

  # First, clean the BE old pkgs
  echo "Preparing the new boot-environment..."
  rc_halt "chroot ${STAGEMNT} pkg delete -ay"

  # Next create the script to bootstrap pkgng
  echo "#!/bin/sh
tar xvpf ${REALPKGDLCACHE}/${PKGFILENAME} -C / /usr/local/sbin/pkg-static >/dev/null 2>/dev/null
/usr/local/sbin/pkg-static add -f ${REALPKGDLCACHE}/${PKGFILENAME}
if [ \$? -ne 0 ] ; then exit 1; fi
cd ${REALPKGDLCACHE}

# Cleanup the old /compat/linux for left-overs
umount /compat/linux/proc >/dev/null 2>/dev/null
umount /compat/linux/sys >/dev/null 2>/dev/null
rm -rf /compat/linux
mkdir -p /compat/linux/proc
mkdir -p /compat/linux/sys

echo \"Installing $SYSBASEFILENAME...\"
pkg add $SYSBASEFILENAME >/pkg-add.log 2>/pkg-add.log
if [ \$? -ne 0 ] ; then exit 1; fi

while read pkgLine
do
  pkgOrigin=\"\`echo \$pkgLine | cut -d ' ' -f 1\`\"
  pkgName=\"\`echo \$pkgLine | cut -d ' ' -f 2\`\"
  if [ ! -e \"\${pkgName}\" ] ; then
     echo \"No such package: \${pkgName}\"
     echo \"No such package: \${pkgName}\" >>/removed-pkg-list
     continue
  fi

  echo \"Installing \$pkgName...\"
  pkg add \${pkgName} >/pkg-add.log 2>/pkg-add.log
  if [ \$? -ne 0 ] ; then
     echo \"Failed installing \${pkgName}\"
     cat /pkg-add.log
     echo \"Failed installing \${pkgName}\" >>/failed-pkg-list
     cat /pkg-add.log >>/failed-pkg-list
  fi
done < /install-pkg-list
rm /pkg-add.log

echo \"Extracting ports overlay...\"
/usr/local/bin/pc-extractoverlay ports
if [ \$? -ne 0 ] ; then exit 1; fi

echo \"Updating pkgng config...\"
/usr/local/bin/pc-updatemanager syncconf
if [ \$? -ne 0 ] ; then exit 1; fi

# Save the log files
if [ ! -d \"/usr/local/log/pc-updatemanager\" ] ; then
  mkdir -p /usr/local/log/pc-updatemanager
fi
touch /install-pkg-list
touch /removed-pkg-list
touch /failed-pkg-list
mv /install-pkg-list /usr/local/log/pc-updatemanager/
mv /removed-pkg-list /usr/local/log/pc-updatemanager/
mv /failed-pkg-list /usr/local/log/pc-updatemanager/

exit 0
" > ${STAGEMNT}/.doPkgUp.sh

}

install_pkgs_chroot()
{
  # Run it now
  rc_halt "chroot ${STAGEMNT} sh /.doPkgUp.sh"
  rm ${STAGEMNT}/.doPkgUp.sh
}

prep_rc_script()
{
  # Start the upgrade with freebsd-update, get files downloaded and kernel installed
  rc_halt "chroot ${STAGEMNT} freebsd-update --non-interactive -r $NEWFREEBSDVERSION upgrade"
  rc_halt "chroot ${STAGEMNT} freebsd-update install"

  # Now prep the RC script to do the rest of the upgrade after reboot
  rc_halt "chroot ${STAGEMNT} mv /etc/rc /etc/rc-orig"
  rc_halt "chroot ${STAGEMNT} mkdir -p /compat/linux/proc"
  rc_halt "chroot ${STAGEMNT} mkdir -p /compat/linux/sys"
  rc_halt "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc"
  rc_halt "cp ${PROGDIR}/rc-update ${STAGEMNT}/etc/rc-update"
  rc_halt "cp ${PROGDIR}/rc-doupdate ${STAGEMNT}/etc/rc-doupdate"
}

umount_stage_be()
{
  if [ ! -d "${STAGEMNT}/usr/local/log/pc-updatemanager" ] ; then
     mkdir -p "${STAGEMNT}/usr/local/log/pc-updatemanager"
  fi
  rc_halt "cp ${PKGUPGRADELOG} ${STAGEMNT}/usr/local/log/pc-updatemanager/upgrade.log"

  # Now cleanup / unmount
  rc_halt "umount -f ${STAGEMNT}/dev"
  rc_halt "beadm umount -f ${STAGEBE}"
}

mk_stage_be_default()
{
  nDate=`date "+%Y%m%d_%H%M%S"`
  if [ -n "$NEWFREEBSDVERSION" ] ; then
    beName="${NEWFREEBSDVERSION}-up-${nDate}"
  else
    beName="`uname -r`-up-${nDate}"
  fi
  rc_halt "beadm rename $STAGEBE $beName"
  rc_halt "beadm activate $beName"
  rc_halt "grub-mkconfig -o /boot/grub/grub.cfg"

  # TODO Make active BE the top of GRUB menus always
  # This may need to be done in grub2-pcbsd
}

# Make sure this is a valid jail
set_jail_mode()
{
  # Check if this is a JID
  jls | grep -v "JID" | tr -s ' ' | sed 's,^[ \t]*,,' | grep -q "^$1 "
  if [ $? -eq 0 ] ; then
    INJAIL="$1"
    PKG_FLAG="-j $1"
    return
  fi
	
  # Is this a hostname?
  line=`jls | grep -v "JID" | tr -s ' ' | sed 's,^[ \t]*,,' | grep -w "$1" | head -n 1`
  if [ -n "$line" ] ; then
    INJAIL="`echo $line | awk '{print $1}'`"
    PKG_FLAG="-j $INJAIL"
    return
  fi

  exit_err "No such jail: $1"
}

test_jail_netaccess()
{
  # Confirm we have internet access in this jail
  jexec $INJAIL ping -c 2 -q www.pcbsd.org >/dev/null 2>/dev/null
  if [ $? -ne 0 ] ; then
    exit_err "No internet access in JID: $INJAIL"
  fi
}

do_auto_be()
{
  # User requested a new autobe to be created
  create_auto_beadm
}

if [ "`id -u`" = "0" ] ; then
  # Make the installed directory for this version
  if [ ! -d "${INSDIR}/${SYSVER}" ] ; then mkdir -p ${INSDIR}/${SYSVER} ; fi

  # Make the ignore directory for this version
  if [ ! -d "${IGNDIR}/${SYSVER}" ] ; then mkdir -p ${IGNDIR}/${SYSVER} ; fi
fi

if [ $# -eq 0 ] ; then
   show_usage
   exit 1
fi

while [ $# -gt 0 ] ; do

   case $1 in
	  autobe) do_auto_be ;;
  	   check) if [ -n "$INJAIL" ] ; then
		     exit_err "Cannot run this inside a jail..."
		  fi
		  do_fbsdcheck
		  get_update_file
                  do_check ; break ;;
        branches) get_update_file
                  list_branches ; break ;;
        chbranch) get_update_file
                  do_branch "${2}" ; break ;;
	pkgcheck) checkup_pkgs ; break ;;
	syncconf) sync_pkgconf ; break ;;
       confcheck) check_pkgconf ; break ;;
       pkgupdate) update_pkgs_only "$2" ; break ;;
 	 install) if [ -n "$INJAIL" ] ; then
		     exit_err "Cannot run this inside a jail..."
		  fi
		  get_update_file
                  do_install "${2}" ; break ;;
            cron) if [ -n "$INJAIL" ] ; then
                     exit_err "Cannot run this inside a jail..."
                  fi
                  waittime=$(jot -r 1 1 3600)
                  sleep $waittime
                  do_fbsdcheck
                  get_update_file
                  do_check
                  checkup_pkgs ; break ;;
       -j) shift 
	   set_jail_mode "$1"
           ;;
	*) show_usage ;;
   esac
   shift
done

exit 0

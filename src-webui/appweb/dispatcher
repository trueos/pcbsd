#!/bin/sh
# License: BSD
# Author: Kris Moore
# 
# Dispatch script, run as root, allows www process to run 
# specific commands with priv
#
# Also runs as a daemon to process the said commands that appcafe
# wants to have run

# queue commands
# <app> <origin> <flag> <target>
# app = pbi / pkg
# origin = www/firefox or other PBI/PKG origin
# flag = install/delete/info
# target = __system__ / <jailname>

PATH="$PATH:/usr/local/bin:/usr/local/sbin"
export PATH

# QUEUE File
QTMPDIR="/var/tmp/appcafe"
QLOGDIR="${QTMPDIR}/logs"
QLIST="${QTMPDIR}/dispatch-queue"
QWRK="${QLIST}.working"
QLOG="${QLIST}.log"
QRESULTS="${QLIST}.results"

init_daemon()
{
  # Appweb tmp dir
  if [ ! -d "$QTMPDIR" ] ; then
     mkdir ${QTMPDIR}
  fi
  if [ ! -d "$QLOGDIR" ] ; then
     mkdir ${QLOGDIR}
  fi

  chmod 600 ${QTMPDIR}
  chmod 600 ${QLOGDIR}

  # Cleanup old daemon runtime
  rm /var/tmp/appcafe/* 2>/dev/null >/dev/null
  rm /var/tmp/appcafe/logs/* 2>/dev/null >/dev/null

  for i in $QWRK $QRESULTS
  do
    if [ ! -e "$i" ] ; then
      touch $i
      chmod 600 $i
    fi
  done
}

run_queue_cmd()
{
  # Breakdown the line into individual flags
  app=`echo $1 | cut -d " " -f 1`
  origin=`echo $1 | cut -d " " -f 2`
  flag=`echo $1 | cut -d " " -f 3`
  target=`echo $1 | cut -d " " -f 4`

  # Get the uniq identifier for this cmd
  local ident="`echo $1 | sha256 -q`"


  # Sanity check some of the given options
  case $app in
   pkg|pbi) case $flag in
            install|delete|info) ;;
                   *) echo "Unauthorized command specified: $1" >> ${QLOG}
                      echo "FAILED $ident $@" >> $QRESULTS
                      return 1
                      ;;
            esac
            ;;
 pkgupdate) target="$origin" ;;
    warden) case $origin in
	       create|delete) ;;
		   *) echo "Unauthorized warden command specified: $1" >> ${QLOG}
                      echo "FAILED $ident $@" >> $QRESULTS
                      return 1 ;;
	    esac
	    flag="install" ;;
         *) echo "Unauthorized command specified: $1" >> ${QLOG}
            echo "FAILED $ident $@" >> $QRESULTS
            return 1
            ;;
  esac

  
  # Now build the command
  if [ "$app" == "pbi" ];then
     cmd="pbi"
     if [ "$target" != "__system__" ] ; then
       cmd="$cmd $flag -j $target $origin"
     else
       cmd="$cmd $flag $origin"
     fi
  elif [ "$app" == "pkg" ];then
     cmd="pkg"
     if [ "$target" != "__system__" ] ; then
       cmd="$cmd -j $target"
     fi
     cmd="$cmd $flag -y $origin"
  elif [ "$app" == "pkgupdate" ];then
     cmd="pc-updatemanager"
     if [ "$target" != "__system__" ] ; then
       cmd="$cmd -j $target"
     fi
     cmd="$cmd pkgupdate"
  elif [ "$app" == "warden" ];then
     cmd="$1"
  fi

  # Remove any old ident lines from results
  sed -i '' "/ $ident /d" ${QRESULTS}

  # Lets run the command now
  echo "Running: $cmd" >$QLOG 2>$QLOG
  $cmd >>$QLOG 2>>$QLOG
  err=$?
  if [ $err -ne 0 ] ; then
     echo "FAILED $ident $@" >> $QRESULTS
  else
     echo "SUCCESS $ident $@" >> $QRESULTS
  fi

  # If we installed something into a jail, refresh them
  if [ "$target" != "__system__" ] ; then
     pc-systemflag WARDENUPDATE SUCCESS
  fi

  # Save the log file for later diagnostics
  mv ${QLOG} ${QLOGDIR}/${ident}.log
  chmod 644 ${QLOGDIR}/${ident}.log

  return $err
}

run_daemon()
{
  pid="/var/run/appcafe-dispatcher.pid"

  # Check if we have another copy of the daemon running
  if [ -e "${pid}" ] ; then
     pgrep -F ${pid} >/dev/null 2>/dev/null
     if [ $? -eq 0 ] ; then return 0; fi
  fi
  echo "$$" > ${pid}

  # Setup the daemon files
  init_daemon

  # Run the main loop
  while :
  do
    # Check if we have anything to do?
    if [ ! -e "$QLIST" ] ; then
       sleep 10
       continue
    fi

    # Move the queue over and run it
    mv $QLIST ${QLIST}.tmp
    while read line
    do
       echo "$line" > $QWRK
       run_queue_cmd "$line"
       echo "" > $QWRK
    done < ${QLIST}.tmp
    rm ${QLIST}.tmp

    # Done with pkg ops, lets inform syscache to refresh
    pc-systemflag SYSCACHE UPDATE
  done

  rm $pid
}

list_status()
{
  if [ -e "$QLIST" ] ; then
     cat ${QLIST}
  fi
  if [ -e "$QLIST.tmp" ] ; then
     cat ${QLIST}.tmp
  fi
}

list_results()
{
  if [ -e "$QRESULTS" ] ; then
    cat ${QRESULTS} 
  else
    echo ""
  fi
}

display_log()
{
  if [ -e "${QLOGDIR}/${1}.log" ] ; then
    cat ${QLOGDIR}/${1}.log
  else
    echo ""
  fi
}

run_warden_cmd()
{
  case $2 in
      start) warden start $3;;
       stop) warden stop $3;;
       auto) warden auto $3;;
        set) warden set $3;;
          *) echo "Non-dispatch-approved warden command: $2" ;;
  esac
}

run_service_cmd()
{

  local jid=""
  sname="$3"
  sscript="$4"
  if [ "$5" != "__system__" ] ; then
     jid="$5"
     jdir=`jls | grep " ${jid} " | awk '{print $4}'`
     rcfile="${jdir}/etc/rc.conf"
  else
     rcfile="/etc/rc.conf"
  fi

  case $2 in
       stop) # First, stop the service
	     if [ -n "$jid" ] ; then
	        jexec $jid service $sscript stop
             else
                service $sscript stop
	     fi 
	     # Now disable rc.conf entry
	     sed -i '' "/^${sname}_enable=\"YES\"/d" ${rcfile}
             ;;
      start) # First, enable the service
	     sed -i '' "/^${sname}_enable=\"NO\"/d" ${rcfile}
	     sed -i '' "/^${sname}_enable=\"YES\"/d" ${rcfile}
	     echo "${sname}_enable=\"YES\"" >> ${rcfile}

	     if [ -n "$jid" ] ; then
	        jexec $jid service $sscript start
             else
                service $sscript start
	     fi 
             ;;
    restart) # Restart the service 
	     if [ -n "$jid" ] ; then
	        jexec $jid service $sscript restart
             else
                service $sscript restart
             fi
             ;;
          *) echo "Non-dispatch-approved service command: $2" ;;
  esac
}

print_usage()
{
  echo "Dispatcher usage:
--------------------------------
   warden {start|stop} {jail}
   queue {pkg|pbi} {origin} {install/delete/info} {__system__|<jailname>}
   pkgupdate {__system__|<jailname>}
   service {start|stop|restart} {servicetag} {servicerc} {__system__|<jid>}
   daemon
   status
   results 
   log {hash}
" 
}

case $1 in
    # Figure out which warden command we are using
    warden) case $2 in
              # These commands will be queued
              create|delete) echo "$@" >>${QLIST} ;;
	      # These commands can be run immediately
	      start|stop|auto|set) run_warden_cmd $@ ;;
	      *) echo "Invalid warden command! $2" ; exit 1 ;;
	    esac
	    ;;
    # Commands that interact with services
   service) run_service_cmd $@ ;;
    # These commands interact with the dispatcher daemon
     queue) echo "$@" | cut -d ' ' -f 2- >>${QLIST} ;;
 pkgupdate) echo "pkgupdate $2" >>${QLIST} ;;
    daemon) run_daemon ;;
       log) display_log "$2" ;;
    status) list_status ;;
   results) list_results ;;
         *) print_usage ; exit 1 ;;
esac

exit 0
